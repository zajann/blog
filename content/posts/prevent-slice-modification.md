+++

title = "[Go] 누가 내 Slice를 옮겼을까"
date = 2020-11-23T01:44:49+09:00
tags = ["go"]
categories = ["devnote"]
draft = false

+++

얼마 전 커뮤니티에 `slice를 인자로 넘길 때 변조를 방지할 수 있는 방법` 에 대한 질문이 올라왔다. 해당 질문을 토대로 slice의 변조를 방지할 수 있는 방법을 정리해본다.

기본적으로 Go의 slice 자료형은 내부 배열을 참조하고 있는 포인터이다. 따라서 포인터인 slice를 인자로 넘긴다는 것은 그 값이 변경 될 수 있음을 의미하고 이 사실은 go 개발자들이 슬라이스를 사용할 때 항상 염두해야 할 사항 중 하나이다. 

사실 슬라이스의 값이 외부에서 변경되는 것은 잘못된 것이 아니다. 우리가 주의해야 할 것은 의도하지 않은 값의 변경이나 외부에서의 변경이 예기치 않게 원본 슬라이스에 영향을 끼칠 수 있다는 것이다. 

`예기치 않은 값의 변조` 라는 실수를 방지하기 위한 방법을 알아보기 전에 슬라이스를 인자로 넘겼을 때 일어나는 과정을 한번 살펴본다.

## 슬라이스 기본

```go
package main

import "fmt"

func main() {
	s1 := make([]string, 1, 4)
	s1[0] = "origin1"
	add(s1)
	fmt.Println(s1) // [origin1], expect [origin1, add]
}

func add(s2 []string) {
	s2 = append(s2, "add")
}
```

위 결과에서 꽤 흥미로운 사실이 하나 있다. 위 코드에서 포인터인 슬라이스를 인자로 넘겼고 외부에서 `append` 를 통해 값을 추가 했는데 원본 슬라이스에 영향을 끼치지 않은 것이다. 참조하는 내부배열의 크기도 여유가 있기 때문에 새로운 내부 배열을 생성한 것도 아닌데 말이다. 이 같은 결과가 나올 수 있는 것은 슬라이스가 `길이`와 `용량` 이라는 값을 가지기 때문이다. 

결론부터 말하면 `s1`과 `s2` 가 표현하려는 배열의 길이가 다르기 때문에 원본 배열이 변하지 않은 것처럼 `보여지는 것`이다. 실제 두 슬라이스가 참조하는 내부 배열에는 "add"라는 값이 추가 되었을 것이다. 슬라이스 자료형의 의미를 풀어 해석하면, `s1` 는 `주소값 x로 시작하고 크기가 4인 string 배열 중 시작점부터의 길이가 1만큼 표현` 이라고 할 수 있다. `append` 내장 함수는 내부 배열에 값을 추가하고 슬라이스의 길이를 증가 시킨다. 따라서 `s2` 는 `주소값 x로 시작하고 크기가 4인 string 배열 중 시작점부터의 길이가 2만큼 표현` 이라 해석 할 수 있다. 결과적으로 `s1` 과 `s2`는 서로 같은 내부 배열을 참조하지만 표현할 길이가 다르기 때문에 서로 다른 배열을 참조하는 것처럼 보여지는 것이다. 참고로 `append` 없이 강제로 슬라이스의 길이를 증가 시킬 수 있는 방법은 없다. 슬라이스가 배열을 얼마나 유연하고 효율적으로 사용할 수 있도록 고안되었는지를 느낄 수 있는 대목이다.

## 방법 1. 슬라이스 copy해서 넘기기 / copy해서 사용하기

예기치 않은 슬라이스의 변조를 막기 위한 가장 기본적인 방법으로는 슬라이스를 넘길 때 해당 슬리이스를 복사해서 넘기거나 인자로 넘어온 슬라이스를 복사하여 사용하는 것이다. 

```go
package main

import "fmt"

func main() {
	s := make([]string, 2)
	s[0] = "origin1"
	s[1] = "origin2"
	add(s[:1])
	fmt.Println(s)
}

func add(s2 []string) {
	var newSlice []string
	copy(newSlice, s2) // prevent modification
	newSlice = append(newSlice, "add")
}
```

슬라이스 복사를 해서 넘기는 것보다 값의 변조를 일으킬 수 주체 쪽, 즉 인자로 넘어온 슬라이스를 사용하는 쪽에서 복사하는 것이 더 낫다고 생각한다. 하지만 슬라이스를 인자로 호출하는 함수의 정확한 내부 로직을 알지 못한다면 전자의 방법으로 원본을 안전하게 유지하는 것이 나을 것이다. 이 방법은 값을 새로운 그릇에 담아 넘기는 것이기 때문에 원본에 영향을 끼치지 않을 가장 확실한 방법이다. 하지만 동일 값을 갖는 새로운 메모리를 할당한다는 것이기 때문에 메모리 낭비가 있을 수 있고 성능 상에도 패널티가 있다.

## 방법 2. 슬라이스 길이와 용량을 같게 하여 전달

이 아이디어는 `append` 시 슬라이스의 용량이 초과하면 확장된 내부 배열을 새로 할당하여 연결한다는 점을 이용하는 것이다. 슬라이스를 인자로 넘길 때 길이와 용량을 같게 만든다면 전달 받은 쪽에서 `append` 하더라도 이는 새로운 내부 배열일 것이기 때문에 원본과 분리될 것이다. 

```go
s1 := make([]string, 10)			// len:10 / cap:10
s2 := make([]string, 10, 20)		// len:10 / cap:20
```

위 코드로 만들어진 `s1` 과 `s2` 는 모두 그대로 전달 되었을 때 예기치 않은 변조가 일어날 확률이 적다. `s1` 의 경우 이미 길이와 용량이 같게 맞춰진 상태이고 `s2`의 경우 길이와 용량이 서로 다르지만 앞서 알아본 것처럼 외부에서 `append` 가 일어나더라도 길이가 다르기 때문에 원본에 영향이 없다. 예기치 않은 변조가 일어날 수 있는 경우는 슬라이스를 `슬라이싱`하여 전달할 때이다.

```go
s2 := make([]string, 10, 20)	// len:10 / cap:20
s3 := s2[1:5]					// len:4 / cap:19
```

위에서 `s3`은 `s2`를 슬라이싱하여 만들어진 슬라이스로 인덱스 1,2,3,4 까지를 표현한다. 이때 만약 `s3`에서 `append`를 한다면 원본인 `s2`의 값에 영향을 끼친다. 조금 더 자세히 말하면 `s2` 인덱스 5부터 값이 변경될 수 있다. 이유는 `s3`의 용량이 19로 `s3`입장에서는 그 용량이 충분하기 때문에 바로 뒤에 값을 추가하기 때문이다. 이때 `s3`의 용량을 길이와 맞춰줄 수 있다면 이런 현상을 방지할 수 있는데 그 방법은 슬라이스 시 3번째 인덱스를 사용하는 것이다.

```go
s3 := s2[1:5:5]		// len:4 / cap:4
```

go에서 슬라이스를 슬라이싱할 때 3번째 인덱스 값을 지정할 수 있는데, 이 값은 `슬라이스의 용량을 제한` 하는 역할을 한다. 시작점으로 부터 지정한 인덱스까지를 용량을 갖겠다는 의미인데 위 코드의 `[1:5:5]` 를 해석 하면 `1번 인덱스부터 (5-1)인덱스까지를 표현하고 용량은 인덱스 1부터 5까지의 길이인 4로 설정` 이라고 할 수 있다. 같은 원리로 `[3:8:10]`인 슬라이스는 길이가 5, 용량은 7이 된다. 이 방법을 통해 인자로 넘길 슬라이스의 길이와 용량을 같게 만들어 넘김으로써 실수를 방지할 수 있다.

```go
package main

import (
	"fmt"
)

func main() {
	s1 := make([]string, 2)
	s1[0] = "origin1"
	s1[1] = "origin2"
	add(s1[:1:1]) // prevent modification
	fmt.Println(s1)
}

func add(s2 []string) {
	s2 = append(s2, "add")
}
```

## 마무리

앞서 `슬라이스 기본`에서 알아본 내용 중 의아한 부분이 하나 있다. 원본 슬라이스와 인자로 넘긴 슬라이스는 동일한 내부 배열을 참조하고 있는데, 만약 양쪽에서 모두 `append` 를 한다면 어떻게 되는가이다.

```go
package main

import (
	"fmt"
	"time"
)

func main() {
	s1 := make([]string, 1, 4)
	s1[0] = "origin1"
	go add(s1)
  time.Sleep(time.Second)	// wait add done
  s1 = append(s1, "add2")
  for{
    time.Sleep(time.Second)
  }
}

func add(s2 []string) {
	s2 = append(s2, "add")
  for {
    fmt.Println(s2)	// [origin1, add2], expect [origin1, add]
    time.Sleep(time.Second)
  }
}
```

답은 간단하게 `덮어쓴다` 이다. 각 슬라이스는 독립적으로 내부 배열을 참조하고 값이 쓰여질 공간에 다른 값이 있다면 그 값을 덮어쓴다. 동일한 내부 배열을 참조하고 있는 자신 외 다른 슬라이스들과의 상호 연관성을 고려하지 않는다는 것이다. 단순하고 깔끔한 방법이지만 예기치 않은 상황이 일어날 수 있는 여지가 많기 때문에 개발자들은 슬라이스를 사용할 때 `나의 이 행위가 어떤 영향을 미칠 것인지`를 항상 염두해야하고 위와 같은 방법 등으로 실수를 방지해야 한다.

위에 정리한 두 방법 중 개인적으로 `copy`를 이용한 방법이 나아보인다. 두번째 방법이 더 편해보이긴 하지만 `append` 를 하기 전까지는 같은 내부 배열을 참조하고 있으므로  여전히 위험요소는 존재한다. 하지만 첫번째는 값을 복사하여 사용하는 것이기 때문에 원본에 영향을 끼칠 위험요소가 없다. 메모리가 아깝고 성능 상 문제가 있을 수 있다고하지만 어마어마한 양의 데이터를 담고 있거나 퍼포먼스에 극도로 예민한 상황이 아니라면 큰 문제는 아니지 않을까라는 생각이다.

Go 슬라이스는 참 단순해보이는데 복잡하고 별거 아닌거 같은데 대단하다.